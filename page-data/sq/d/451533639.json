{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/","title":"system-design-interview-book-club"},"frontmatter":{"draft":false},"rawBody":"# system-design-interview-book-club\n\n網站版: <https://warren30815.github.io/system-design-interview-book-club>\n\nEnglish Book: [System Design Interview – An insider's guide: Xu, Alex (Volume 1)](<https://github.com/G33kzD3n/Catalogue/blob/master/System%20Design%20Interview%20An%20Insider%E2%80%99s%20Guide%20by%20Alex%20Xu%20(z-lib.org).pdf>) \n\nChinese Translation: [內行人才知道的系統設計面試指南](https://www.books.com.tw/products/0010903454)\n\n| Chapter                                                        | Speaker            | Date  | Completed | Link of Notes                     |\n| -------------------------------------------------------------- | ------------------ | ----- | --------- |-----------------------------------|\n| CHAPTER 1: SCALE FROM ZERO TO MILLIONS OF USERS                | Jay / Fienna Liang | 06/09 | ✅        | [Chapter 1](content/chapter_1.md) |\n| CHAPTER 2: BACK-OF-THE-ENVELOPE ESTIMATION                     |                    |       | ✔️         |                                   |\n| CHAPTER 3: A FRAMEWORK FOR SYSTEM DESIGN INTERVIEWS            |                    |       | ✔️         |                                   |\n| CHAPTER 4: DESIGN A RATE LIMITER                               | 杯 / 雷N           | 06/16 | ✔️         | [Chapter 4](content/chapter_4.md)   |\n| CHAPTER 5: DESIGN CONSISTENT HASHING                           | 雷N                | 06/30 | ✔️         |                                   |\n| CHAPTER 6: DESIGN A KEY-VALUE STORE                            | 雷N                | 07/07 | ✔️         |                                   |\n| CHAPTER 7: DESIGN A UNIQUE ID GENERATOR IN DISTRIBUTED SYSTEMS | Jordan             | 06/23 | ✔️         |                                   |\n| CHAPTER 8: DESIGN A URL SHORTENER                              | Jordan             | 06/23 | ✔️         |                                   |\n| CHAPTER 9: DESIGN A WEB CRAWLER                                |                    |       | ✔️         |                                   |\n| CHAPTER 10: DESIGN A NOTIFICATION SYSTEM                       | 雷N                | ??/?? | ✔️         |                                   |\n| CHAPTER 11: DESIGN A NEWS FEED SYSTEM                          |                    |       | ✔️         |                                   |\n| CHAPTER 12: DESIGN A CHAT SYSTEM                               |                    |       | ✔️         |                                   |\n| CHAPTER 13: DESIGN A SEARCH AUTOCOMPLETE SYSTEM                |                    |       | ✔️         |                                   |\n| CHAPTER 14: DESIGN YOUTUBE                                     |                    |       | ✔️         |                                   |\n| CHAPTER 15: DESIGN GOOGLE DRIVE                                |                    |       | ✔️         |                                   |\n| CHAPTER 16: THE LEARNING CONTINUES                             |                    |       | ✔️         |                                   |\n\n> Note: Use [Markdown table generator](https://www.tablesgenerator.com/markdown_tables) to load, modify and format the table\n\n<img width=\"371\" alt=\"截圖 2023-06-05 上午10 22 08\" src=\"https://github.com/warren30815/system-design-interview-book-club/assets/36834814/c634e1e9-f1e3-46af-95b6-1ae14bc3887a\" />\n"},{"fields":{"slug":"/content/chapter_1/","title":"第一章：使用者人數 -- 從零到百萬規模"},"frontmatter":{"draft":false},"rawBody":"# 第一章：使用者人數 -- 從零到百萬規模\n\n此篇主要在講最簡單的單台主機設置，到百萬規模的系統，中間如何逐步加入各個元件，以及每個元件如何擴展。\n經過第一章的介紹，便可以對一個可規模化 (scalable) 的系統有相對完整與綜觀的認識。\n\n## 單台主機\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. DNS server\n3. Web server\n\n主要流程：\n\n1. 客戶端發起請求\n2. DNS 伺服器解析出網站伺服器 IP\n3. 網站伺服器處理流量\n\n## 資料庫\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. DNS server\n3. Web server\n4. Database\n\n主要流程：\n\n1. 客戶端發起請求\n2. DNS 伺服器解析出網站伺服器 IP\n3. 網站伺服器處理流量\n4. 網站伺服器向資料庫請求資料，或送出資料修改請求\n\n資料庫型態：\n\n1. 關聯式資料庫 (RDBMS)\n2. 非關聯式資料庫 (NoSQL)\n   1. CouchDB\n   2. Cassandra\n   3. Hbase\n   4. AWS DynamoDB\n\n## 擴展\n\n1. 垂直擴展：加大機器的 CPU, memory, disk 等硬體處理能力。但存在以下問題：\n   1. 一台機器的運算與儲存擴展有硬體上的極限\n   2. 會造成單點故障 (single point of failure), 即系統的單一節點故障便導致整個系統變得不可用\n2. 水平擴展：增加更多台機器。能夠解決以上問題，也是在討論擴展時的主要對策。\n\n## 負載平衡 (Load Balancer)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. DNS server\n3. *Load Balancer*\n4. Web server\n5. Database\n\n主要流程：\n\n1. 客戶端發起請求\n2. DNS 伺服器解析出網站伺服器 IP\n3. *負載平衡接收流量後往後面多台機器分配請求*\n4. 多台網站伺服器處理流量\n5. 網站伺服器向資料庫請求資料，或送出資料修改請求\n\n解決的問題\n\n1. 可透過增加網頁伺服器數量來處理更多的請求，解決了擴展性的問題 (scalability)\n2. 當有一台機器故障時，負載平衡器可以將請求發送至其他運作中的機器，增加了可用性 (availability)\n\n注意事項：\n\n1. 由於資安因素，通常網頁伺服器會透過內網通訊，只有負載平衡器連接外網\n2. 負載平衡器可能變成系統中單點故障所在，但可使用 DNS server 的循環解析 (Round-robin DNS resolution) 或其他方式來解決單點故障問題\n\n## 資料庫複製 (Database Replication)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. DNS server\n3. Load Balancer\n4. Web server\n5. *Database with multiple replica*\n\n主要流程：\n\n1. 客戶端發起請求\n2. DNS 伺服器解析出網站伺服器 IP\n3. 負載平衡接收流量後往後面多台機器分配請求\n4. 多台網站伺服器處理流量\n5. 網站伺服器向資料庫請求資料，或送出資料修改請求\n6. *資料庫主節點(master)負責處理寫入與讀取，從節點(slave)負責處理讀取請求*\n\n解決的問題\n\n1. 當讀取資料的請求很多時，從節點可分攤讀取請求，並且可透過增加從節點來達成擴展\n2. 資料備份：即使有節點損毀，依然能保證可以從其他節點獲得完整的數據\n\n## 快取 (Cache)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. DNS server\n3. Load Balancer\n4. Web server\n5. *Cache*\n6. Database with multiple replica\n\n主要流程：\n\n1. 客戶端發起請求\n2. DNS 伺服器解析出網站伺服器 IP\n3. 負載平衡接收流量後往後面多台機器分配請求\n4. 多台網站伺服器處理流量\n5. 網站伺服器向*快取*請求資料，或送出資料修改請求\n6. *快取負責暫時性儲存資料，回應伺服器需求*\n7. 資料庫主節點(master)負責處理寫入與讀取，從節點(slave)負責處理讀取請求\n\n注意事項\n\n1. 使用快取最需要關注的問題是決定何時資料是失效的，可能的方法有\n   1. 快取壽命 (Time to live, TTL)：快取資料經過特定時間長度後即視為無效\n   2. Read-through：快取接收到請求時判別有沒有資料，有就回傳，沒有的話從資料庫拿取，回應請求，並貯存在快取中\n   3. Write-through：服務接收到寫入請求時，同時往快取與資料庫寫入資料，以保證資料都是最新的。缺點是兩邊都要寫入可能導致回應時間變長\n2. 快取滿了的時候的處理方式\n   1. LRU (Least-recently-used)：上次被使用時間距今最久的先清掉\n   2. LFU (Least-frequently-used)：最不常使用到的先清掉\n   3. FIFO (First-in-first-out)：先進來的先清掉\n\n## 內容傳遞網路 (Content Delivery Network, CDN)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. *CDN*\n3. DNS server\n4. Load Balancer\n5. Web server\n6. Cache\n7. Database with multiple replica\n\n主要流程：\n\n1. 客戶端發起請求\n2. *對於靜態資料如圖片或指令碼，CDN 能夠直接回應請求，減少系統負擔*\n3. DNS 伺服器解析出網站伺服器 IP\n4. 負載平衡接收流量後往後面多台機器分配請求\n5. 多台網站伺服器處理流量\n6. 網站伺服器向快取請求資料，或送出資料修改請求\n7. 快取負責暫時性儲存資料，回應伺服器需求\n8. 資料庫主節點(master)負責處理寫入與讀取，從節點(slave)負責處理讀取請求\n\n注意事項：\n\n1. CDN 通常在全球分佈，接收並處理地理距離上較近的請求，以減少回應時間\n2. CDN 也要注意如何使資料無效 (invalidation)，常見的方法有\n   1. TTL：經過一定時間後資料無效\n   2. 版本：在 URL 攜帶版本號，因此當客戶端請求不同版本時，CDN 便會向伺服器詢問最新版的資料\n\n## 伺服器狀態 (Stateful vs Stateless)\n\n### Stateful\n\n伺服器會將使用者資料貯存在同個伺服器上，例如將會話 (session) 存在機器上\n\n問題：當水平擴展時，如果使用者的請求被負載平衡器分配到不同的機器上，則該機器沒有使用者的會話資料，將導致系統出現預期外的行為\n\n### Stateless\n\n伺服器將所有的資料貯存在第三方元件或系統中，而非自身的貯存空間\n\n伺服器在處理請求時，可以把每個請求看成獨立的流程來處理，不需要考慮當下請求跟之前的請求有沒有關聯，也不需要考慮該請求所需要的資訊是否存在自己的貯存空間中\n\n可用的會話資料處存方案：\n1. Memcached\n2. Redis\n3. NoSQL\n\n備注：\n1. 在討論水平擴展時，通常假設伺服器是無狀態的，這樣在部署時就不需要考慮負載平衡器該如何解決前後請求之間的關係\n2. 即使如此，一些負載平衡器還是可以提供所謂\"親和性\"的機制 (affinity)，例如將來自同一個 IP 的請求都分配到同一台機器上\n\n## 資料中心 (Data Centers)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. CDN\n3. DNS server\n4. Load Balancer\n5. *Web server in multiple data centers*\n6. Cache\n7. Database with multiple replica\n\n主要流程：\n\n1. 客戶端發起請求\n2. 對於靜態資料如圖片或指令碼，CDN 能夠直接回應請求，減少系統負擔\n3. DNS 伺服器解析出網站伺服器 IP\n4. 負載平衡接收流量後往後面多台機器分配請求\n5. *多台網站伺服器分布在不同的資料中心中處理流量*\n6. 網站伺服器向快取請求資料，或送出資料修改請求\n7. 快取負責暫時性儲存資料，回應伺服器需求\n8. 資料庫主節點(master)負責處理寫入與讀取，從節點(slave)負責處理讀取請求\n\n注意事項：\n\n1. DNS 通常會根據使用者的地理位置來解析請求，回應請求一個距離使用者較近的資料中心\n2. 這裡雖然用的名稱是 Data Center, 但我認為用 AWS 的 Availability Zone 來說明會更好解釋。即不同的資料中心是在地理距離上分佈相距較遠的，如此一來可以在某區域發生災害時依舊保證有其他地理區域的資料中心依舊可用。例如當 ap-northeast-1 (東京) 的資料中心所在區域發生地震時而導致資料中心不可用時，us-east-2 依舊可用，不會因為地理位置相近而導致所有資料中心同時損毀。\n\n## 訊息隊列 (Message Queue)\n\n關鍵元件：\n\n1. Client (web, mobile)\n2. CDN\n3. DNS server\n4. Load Balancer\n5. Web server in multiple data centers\n6. *Message Queue*\n7. *Workers*\n8. Cache\n9. Database with multiple replica\n\n主要流程：\n\n1. 客戶端發起請求\n2. 對於靜態資料如圖片或指令碼，CDN 能夠直接回應請求，減少系統負擔\n3. DNS 伺服器解析出網站伺服器 IP\n4. 負載平衡接收流量後往後面多台機器分配請求\n5. 多台網站伺服器分布在不同的資料中心中處理流量\n6. 網站伺服器向快取請求資料，或送出資料修改請求。*長時間操作則將資訊送往訊息隊列*\n7. *Worker 接受隊列內的消息並逐一處理*\n8. 快取負責暫時性儲存資料，回應伺服器需求\n9. 資料庫主節點(master)負責處理寫入與讀取，從節點(slave)負責處理讀取請求\n\n注意事項\n\n1. Queue 只是這邊提到的一種方式，其他的訊息溝通系統還包含生產-訂閱 (Pub/Sub) 等機制。\n2. 費時較長且不需要使用者立即得知結果的操作，設計上通常不會由網站伺服器處理，這時就可以讓網站伺服器把這類工作打包成訊息，丟到隊列中，並且由特定的工作伺服器 (worker) 去消化隊列訊息，並異步處理。\n3. 常見的應用情境包含：寄信、影像處理、資料分析。\n4. Queue 的作用還包含服務之間的*去耦合*，即讓接收訊息與處理訊息者不需要了解彼此的部署與實作，並且兩者可以實現不同的擴展策略。\n\n## 日誌、指標、自動化 (Logging, Metrics, Automation)\n\n- 日誌：對於了解服務哪裡出錯以及獲取除錯所需的資訊來說至關重要\n- 指標：了解服務的關鍵資訊，例如回應時間、系統負載、使用者數量、關鍵業務請求數量等\n- 自動化：使用 CI/CD 等手段確保即使系統成長的更加複雜，大量事務能夠被自動化處理，服務能持續運行\n\n## 資料庫水平擴展\n\n擴展方法：\n\n1. 垂直擴展：加大機器處理與貯存的運算能力\n2. 水平擴展：分片 (Sharding)\n\n注意事項\n\n1. 分片需注意使用什麼欄位作為 Sharding key，要避免資料集中在一個分片上\n2. 若要重新分片資料時會是個複雜的挑戰\n3. 名人問題：大量讀取可能都是針對少部分資料，導致特定分片承受大量流量，而其他分片則閒置\n4. 分片會使得要做 join 等聚合操作時變得困難，這些邏輯可能需要在應用層完成\n5. 資料庫擴展方法有很多，這裡提到的主從式架構 Master-slave 只是其中一種，其他還有包含\n   1. Multi-master\n   2. Consistent Hashing\n   3. Partitioning\n   4. Distributed Transaction\n   5. Command Query Responsibility Segregation\n"},{"fields":{"slug":"/content/chapter_4/","title":"第四章：DESIGN A RATE LIMITER"},"frontmatter":{"draft":false},"rawBody":"# 第四章：DESIGN A RATE LIMITER\n\n## # 主軸\n\n- 主要在 Layer 7: Application layer\n\n- 作用：\n\n  - 防止 DoS: 避免資源餓死 (resouce starvation)\n  - 節省流量成本: 流程內可能會調用到第三方服務 (依次計費), 或者 LB 依請求次數計費, 如果能在避免資源餓死的前提下作考量時, 那麼大部分的請求被拒絕時, 自然而然以上的成本會下降\n  - 防止超載: 會打請求的未必只是人還有Bot, 為了避免大家把有限資源的服務器打暴為前提做設計 (更多能參考SLA)\n\n- 目標：\n\n  - server-side API rate limiter\n\n    - REF: client: axios-rate-limit: other will be delayed automatically.\n\n  - a large number of requests --> Low latency & little memory？\n \n  - 聚合用的欄位, 希望足夠彈性\n\n  - exception handling, inform users\n\n  - service (API Gateway) vs server-side code\n\n  - work in distributed environment, 在這裡指的是 Rate limiter 本身可能不只是 cluster, 甚至跨 VPC, 跨 AZ 的環境\n\n  - high fault tolerance: Rate limiter 本身非業務流程上的必要功能, 它本身的好壞不該影響到整個系統, 因此考量時, 該怎設計隔離 rate limte service 某個節點異常的部份\n \n  - low latency: rate limit本身非業務所需功能, 不應該在latency上佔比過高\n\n  - technology stack\n\n  - algorithm 可選性\n\n  - 時間成本\n\n## # Algorithm\n\n- 演算法介紹\n\n  - Token bucket\n\n  - Leaking bucket\n\n  - Fixed window counter\n\n  - Sliding window log\n\n    - 可在每次收到請求時，才清除舊資料。安排固定時間或長度清除\n    \n    Q: 為什麼連被拒絕的請求也要加入 log 做計數？\n    \n    A: 這個的設計其實不是為了直接給 rate limiter 來計算用的，而是其他需求，畢竟叫做 log，像 nginx access log 一樣，有請求來的本來就都會被紀錄，有以下四個常見需求：\n    \n       1. 故障排查用: 被拒絕的請求可能表示系統中存在問題。例如，如果出現許多請求被拒絕，可能意味著系統超負荷、有 bug、或者資源分配不足。透過記錄被拒絕的請求，工程師能夠回溯問題並進行修復。\n       2. 監控系統負載: 大量的被拒絕的請求可能表示系統負載過高或者資源短缺。這些日誌可以作為我們監控系統狀態和評估資源需求的依據。\n       3. 離線用戶行為分析: 對於被拒絕的請求進行記錄和分析，可以幫助我們更好地了解用戶的行為模式，以及那些功能或服務可能存在問題。然後我們就可以對這些問題進行調整和優化。\n       4. 法規和合規需求: 在某些情況下，法規可能要求我們記錄所有的請求，包括被拒絕的請求。\n    \n    ref: [Rate limiting - why log rejected requests' timestamps in Sliding window log algorithm?](https://www.reddit.com/r/AskComputerScience/comments/xktn2j/rate_limiting_why_log_rejected_requests/)\n\n  - Sliding window counter\n\n- 演算法比較\n\n  - Bucket vs Window\n\n    - 可看作 Bucket 可以把可接受的峰值跟均速分開設定，Window 把峰值跟均速綁在一起\n    - 因此 Bucket 需要調整兩個參數達到平衡，也相對較困難\n\n  - Bucket\n\n    - A. Token bucket\n\n      - 適合處理瞬間流量，如搶購\n      - 比 B 更有效的利用資源\n\n    - B. Leaking bucket\n\n      - 穩定輸出模型\n      - 不適合瞬間流量，如搶購。因為即使流量在可接受範圍，依然會按照一個速率進行\n\n  - Window\n\n    - C. Fixed window counter\n\n      - 可能會有時間差聚集現象，實質上超過流量\n\n    - D. Sliding window log\n\n      - 解決 C 的問題，一定不會超過流量限制\n      - 大量耗費記憶體，因為須記錄所有 timestamp\n      - 清除舊資料很耗時\n\n    - E. Sliding window counter\n\n      - 解決 D 的記憶體使用問題，但保有大概率解決 C 的問題，不會超過流量\n      - 實驗統計只有 0.003% 出錯\n\n## # High-level architecture\n\n## # Design deep dive\n\n- Rate limiting rules 怎被建立、儲存、存取和更新: 依照結構化格式(YAML, JSON, XML...)，將規則的欄位給格式化\n\n- Exceeding the rate limit\n\n  - HTTP 429 (Too many requests)\n\n    - 放到待處理\n    - 直接捨棄\n\n  - Rate limiter headers\n\n    - 沒超過限制\n\n      - X-Ratelimit-Remaining: 在時間區間內還剩下多少配額\n      - X-Ratelimit-Limit: 在時間區間內，客戶端請求的限額\n      - X-Rate-Limit-Reset: 一個代表時間的數值，時間到將重設配額\n\n    - 超過限制回傳 429\n\n      - X-Ratelimit-Retry-After: 指定客戶端在傳送下一個要求之前所應等待 (或睡眠) 的秒數。如果重試值沒過就傳送要求，則不會處理要求，並且會回傳新的重試值。\n     \n      **Client需要知道這些資訊，才好控制下一次發出請求 (甚至也能說是一種Retry policy的控制)**\n\n- Detailed design\n\n  Q: 這些資訊適合存放在哪？\n  \n  A: RDBMS太慢且本身的資料結構也不適合存放大量數據，且有熱點存取問題，因此選擇 in memory store 是適合的，夠快且過期的資料通常 in-memory db 有配合的機制能汰除掉，因為我們這裡大部分都只要計次 (sliding window log 例外)，Redis有提供INCR與EXPIRE (甚至TTL機制)，便於使用\n\n- Rate limiter in a distributed environments\n\n  - Race condition (類似超賣問題)\n\n    - Locks\n\n      - 會降低效能，吞吐量會受影響\n\n    - Lua script\n\n      - 因為是「原子性的」\n      - 因為 lock 是對資源層級的鎖定，靈活性較低，以原子性的腳本來做，能夠只在需要的步驟上使用\n\n    - sorted sets data structure\n\n      - [Skip List](https://mecha-mind.medium.com/redis-sorted-sets-and-skip-lists-4f849d188a33)\n\n  - Synchronization issue\n \n    在跨 VPC / AZ 的情況下，很可能 rate limiter 內的資訊與狀態不一致，對同一個user，不同請求會隨機跳轉到不同 rate limiter 上被處理，那就等於白搭了，所以在這裡會建議用同一個 redis cluster，以及啟用 sticky session機制，讓同一個 user 的不同請求都能在同一個 rate limiter 上被處理\n\n    - sticky sessions\n\n      - 讓 client 去固定 rate limiter，不彈性不好擴展\n\n    - centralized data stores\n\n      - REF: [A Comprehensive Guide to Distributed Caching](https://blog.devgenius.io/a-comprehensive-guide-to-distributed-caching-827f1fa5a184)\n\n- Performance optimization\n\n  - multi-data center\n  - eventual consistency model\n    - 相較於完全一致性更有效率，但又保有一致性\n    - chaper 6\n\n- Monitoring\n\n  - 需監控以下兩個面向是否能有效地達到目的\n\n    - rate limiting rules\n    - rate limiting algorithm\n      - EX. flash sales --> Token bucket\n\n## # 延伸討論\n\n- 不同 layer 的防範\n\n  - 在 layer 3 進行較快？\n  - 全公司同一個 ip\n  - 沒登入時 (也可在 layer 7 用 session)\n  - 針對不同類型使用者，不同策略\n  - 不同 layer 的防範，不是選擇，而是一起用，各自防不同面向。但用太多會不會影響到單次請求的效能？\n\n- 加強 client，避免問題\n\n  - client cache\n  - 合理的發送請求？\n  - catch exceptions or errors\n  - back off time：可用指數型成長策略\n\n- Hard vs Soft\n\n  - Hard rate limiting\n\n    - 超過限制的請求將被直接拒絕或返回錯誤\n    - 確保系統在特定時間內不會超過預定的請求速率\n    - 可能導致客戶端體驗不佳\n\n  - Soft rate limiting\n\n    - 允許短期內超過限制的請求，但在長期內維持平均速率不超過預定的限制\n    - 通常使用 Bucket 演算法\n\n- 當服務器「總負載」快要超出限額，會怎麼做？\n\n  - 平均調低 rate limit threshold\n  - 把流量留給重要的請求或用戶\n  - 大家都暫停別用\n  - 機器開下去\n  - 其他\n\n- Circuit breaking（熔斷）和 degradation（降級）\n"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}